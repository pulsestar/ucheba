git-cherry-pick данная программма подходит для того чтоб, применять изменения внесенные некоторым существующими коммитами.

Учитывая один или несколько существующих коммитов, примените изменения, которые вносит каждый, записывая новый коммит для каждого. Это требует, чтобы ваше рабочее дерево было чистым (без изменений из фиксации HEAD).

Когда не очевидно, как применить изменение, происходит следующее:
1.Текущая ветвь и HEADуказатель остаются на последнем успешно сделанном коммите.
2.Ссылка CHERRY_PICK_HEADуказывает на фиксацию, которая внесла изменение, которое трудно применить.
3.Пути, в которых изменения применены корректно, обновляются как в индексном файле, так и в вашем рабочем дереве.
4.Для конфликтующих путей файл индекса записывает до трех версий, как описано в разделе «TRUE MERGE» git-merge. Файлы рабочего дерева будут включать описание конфликта, заключенное в квадратные скобки обычными маркерами конфликта <<<<<<<и расширением >>>>>>>.
5.Никаких других модификаций не делается.

<commit>
Обязуется выбирать вишни. Для более полного списка способов написания коммитов см. gitrevisions. Можно передавать наборы коммитов, но по умолчанию обход не выполняется, как если бы --no-walkбыла указана опция, см. git-rev-list. Обратите внимание, что указание диапазона приведет к тому, что все аргументы <commit>…​ будут переданы в один обход ревизии (см. более поздний пример, в котором используется maint master..next ).

-e
--edit
С этой опцией git cherry-pick позволит вам отредактировать сообщение коммита перед фиксацией.

--cleanup=<mode>
Этот параметр определяет, как сообщение фиксации будет очищаться перед передачей в механизм фиксации. См. git-commit для более подробной информации. В частности, если для <mode> задано значение scissors, ножницы будут добавлены MERGE_MSGперед передачей в случае конфликта.

-x
При записи коммита добавьте строку «(выбрано из коммита…​)» к исходному сообщению коммита, чтобы указать, из какого коммита было выбрано это изменение. Это делается только для выбора вишни без конфликтов. Не используйте эту опцию, если вы выбираете вишни из своей частной ветки, потому что информация бесполезна для получателя. Если, с другой стороны, вы выбираете между двумя общедоступными ветвями (например, портируете исправление в обслуживающую ветку для более старого выпуска из ветки разработки), добавление этой информации может быть полезным.

-r
Раньше считалось, что команда по умолчанию выполняет -x описанное выше и -rдолжна была отключить ее. Теперь по умолчанию не делать этого, -xпоэтому эта опция не работает.

-m <parent-number>
--mainline <parent-number>
Обычно вы не можете выбрать слияние, потому что вы не знаете, какую сторону слияния следует считать основной линией. Эта опция задает номер родителя (начиная с 1) основной ветки и позволяет функции Cherry-pick воспроизвести изменение относительно указанного родителя.

-n
--no-commit
Обычно команда автоматически создает последовательность коммитов. Этот флаг применяет изменения, необходимые для выбора каждого именованного коммита в вашем рабочем дереве и индексе, без каких-либо коммитов. Кроме того, при использовании этой опции ваш индекс не обязательно должен совпадать с фиксацией HEAD. Выбор вишни выполняется против начального состояния вашего индекса.

Это полезно, когда вы выбираете несколько коммитов для вашего индекса подряд.

-s
--signoff
Добавьте Signed-off-byтрейлер в конце сообщения фиксации. См. опцию signoff в git-commit для получения дополнительной информации.

-S[<keyid>]
--gpg-sign[=<keyid>]
--no-gpg-sign
GPG-знак фиксирует. Аргумент keyidявляется необязательным и по умолчанию соответствует идентификатору коммиттера; если он указан, он должен быть прикреплен к опции без пробела. --no-gpg-signполезно отменить как commit.gpgSignконфигурационную переменную, так и более ранние --gpg-sign.

--ff
Если текущий HEAD совпадает с родителем выбранного коммита, то будет выполнена быстрая перемотка вперед к этому коммиту.

--allow-empty
По умолчанию выборка пустого коммита завершится ошибкой, что указывает на то, что требуется явный вызов git commit --allow-empty. Этот параметр переопределяет это поведение, позволяя автоматически сохранять пустые коммиты при выборе вишни. Обратите внимание, что при включении "--ff" пустые коммиты, отвечающие требованию "быстрой перемотки вперед", будут сохранены даже без этой опции. Также обратите внимание, что при использовании этой опции сохраняются только те коммиты, которые изначально были пустыми (т. е. коммит записал то же дерево, что и его родитель). Коммиты, ставшие пустыми из-за предыдущего коммита, удаляются. Чтобы принудительно включить эти коммиты, используйте --keep-redundant-commits.

--allow-empty-message
По умолчанию выборка коммита с пустым сообщением завершится ошибкой. Этот параметр переопределяет это поведение, позволяя выбирать коммиты с пустыми сообщениями.

--keep-redundant-commits
Если выбранный коммит дублирует коммит, который уже есть в текущей истории, он станет пустым. По умолчанию эти избыточные фиксации вызывают cherry-pickостановку, чтобы пользователь мог проверить фиксацию. Этот параметр переопределяет это поведение и создает пустой объект фиксации. Подразумевает --allow-empty.

--strategy=<strategy>
Используйте данную стратегию слияния. Следует использовать только один раз. Подробнее см. в разделе MERGE STRATEGIES в git-merge.

-X<option>
--strategy-option=<option>
Передайте параметр, специфичный для стратегии слияния, в стратегию слияния. Подробности смотрите в git-merge.

--rerere-autoupdate
--no-rerere-autoupdate
Разрешить механизму rerere обновить индекс с результатом автоматического разрешения конфликтов, если это возможно.

ПОДКОМАНДЫ ПОСЛЕДОВАТЕЛЬНОСТИ
--continue
Продолжите текущую операцию, используя информацию в .git/sequencer. Может использоваться для продолжения после разрешения конфликтов при неудачном выборе вишни или возврате.

--skip
Пропустите текущую фиксацию и продолжите остальную часть последовательности.

--quit
Забудьте о текущей операции. Может использоваться для очистки состояния секвенсора после неудачного выбора вишни или возврата.

--abort
Отмените операцию и вернитесь в состояние до последовательности.

ПРИМЕРЫ

git cherry-pick master
Примените изменение, внесенное коммитом, на кончике ветки master, и создайте новый коммит с этим изменением.

git cherry-pick ..master
git cherry-pick ^HEAD master
Примените изменения, внесенные всеми коммитами, которые являются предками master, но не HEAD, для создания новых коммитов.

git cherry-pick maint next ^master
git cherry-pick maint master..next
Примените изменения, внесенные всеми коммитами, которые являются предками maint или next, но не master или любым из его предков. Обратите внимание, что последнее не означает maintи все между masterи next; в частности, maintне будет использоваться, если он включен в master.

git cherry-pick master~4 master~2
Примените изменения, внесенные пятым и третьим последним коммитами, на которые указывает мастер, и создайте 2 новых коммита с этими изменениями.

git cherry-pick -n master~1 next
Примените к рабочему дереву и индексу изменения, внесенные предпоследним коммитом, на который указывает master, и последним коммитом, на который указывает next, но не создавайте никаких коммитов с этими изменениями.

git cherry-pick --ff ..next
Если история линейна и HEAD является предком следующего, обновите рабочее дерево и переместите указатель HEAD, чтобы он соответствовал следующему. В противном случае применить изменения, внесенные теми коммитами, которые находятся в следующем, но не в HEAD, к текущей ветке, создавая новый коммит для каждого нового изменения.

git rev-list --reverse master -- README | git cherry-pick -n --stdin
Примените изменения, внесенные всеми фиксациями в главной ветке, которые коснулись README, к рабочему дереву и индексу, чтобы результат можно было проверить и при необходимости превратить в одну новую фиксацию.

Следующая последовательность пытается выполнить резервное копирование исправления, но терпит неудачу, потому что код, к которому применяется исправление, слишком сильно изменился, а затем пытается снова, на этот раз уделяя больше внимания сопоставлению строк контекста.

$ git cherry-pick тема^              (1) 
$ git diff                            (2) 
$ git reset --merge ORIG_HEAD         (3) 
$ git cherry-pick -Xтерпеливая тема^   (4)

1.Примените изменение, которое будет показано git show topic^. В этом примере исправление не применяется чисто, поэтому информация о конфликте записывается в индекс и рабочее дерево, а новая фиксация результатов не дает.

2.Суммировать изменения для согласования

3.Отменить выбор вишни. Другими словами, вернитесь в состояние до выбора вишни, сохранив все локальные модификации, которые вы имели в рабочем дереве.

4.Попробуйте еще раз применить внесенное изменение topic^, потратив дополнительное время, чтобы избежать ошибок, связанных с неправильным соответствием строк контекста.
